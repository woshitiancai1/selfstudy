第1章
    - 程序：为了解决特定问题，而使用计算机语言编写的有序
            指令序列的集合。
    
    - 编辑    C语言源文件
    - 预处理  C语言源文件（不包含预处理指令）
    - 编译    目标文件（机器代码文件）
    - 链接    可执行应用程序（.exe）
    - 运行     
    
    - 错误    
        1、语法错误      编译
        2、链接错误      链接
        3、运行时错误    运行
        
第2章
    - 数据类型
        - 保存的数据的类型
        - 内存中数据的存储格式
            - int           补码
                补码：方便计算机底层进行数值+-运算
            - unsigned int  原码/补码
            - char          ASCII码
            - float         符号位+阶码+尾码
        - 每种数据类型的数值表示范围
            - short    
                max：0111 1111 1111 1111   2^15 -1
                min：1000 0000 0000 0000   -2^15
                 -1  1111 1111 1111 1111
                  1  0000 0000 0000 0001
                  0  0000 0000 0000 0000
        - 内存溢出
            Q: short a = 0x7fff;   a+=1;  a=?
            A: 0x8000,  short 类型极小值
        - 浮点数类型不能精确表示数据
                固定的阶码、尾码限定了精度范围
        
    - 常量
        - const所修饰的变量，只读变量，常量
        - 定义的时候必须进行初始化
        - 只能进行读，不能进行写
    
    - 字面值
        - "abcd" 字符串字面值       char *
        - 10     整型字面值         int
        - 3.14   浮点数类型字面值   double
        - 'a'    字符字面值         char
        
        - 10l    long
        - 3.14f  float
    
    - 输入输出
        - printf / scanf
            scanf除了读取字符串以外，都需要加取地址符。
            scanf需要的是地址。
        - getchar / putchar
        - gets / puts
        
    - 变量
        - 合法的标识符
            1、数字、字母、下划线组成
            2、数字不能打头（不能出现在第一个字符）
            3、不能与C语言关键字冲突
            4、在同一作用域，不能重名
        Q：以下选项中，属于合法标识符的是（）：
            A、7zip  B、num$a  C、_7-cout  D、printf
        A: D，printf只是标准库中的一个函数，不是关键字
        
        - 先定义，后使用
        - 先初始化，后参加运算
        
        
- 第3章
    - 运算符
        - 算术运算符
            -   + - * / %
            - /（除）：除号运算符右操作数不能为0
            - %（取余）：取余运算符左右操作数必须为整型
                         取余的结果符号位由左操作数决定
                         -10 % 3   =>   -1
                         10 % -3   =>   1
        - 逻辑运算符
            -   &&  ||  !
            - 结果：  1（真）   0（假）
            - 操作数：非0（真） 0（假）
            Q：有 int num; 现在num不确定，num为0时值不变
               非0时，让它变为1，如何实现？
            A：!!num
            
        - 关系运算符
            -   > < >= <= == !=
            - 写法！！
            - Q：表示[1,10]数值范围
              A：1<=num<=10 （错误）
                 1<=num && num<=10
              Q：表示非[1,10]数值范围
              A：num<1 || num>10
            - 结果  1（真）   0（假）
        - 位运算符
            -   &  |  ~  ^   <<  >>
            -  按位进行相应运算
            Q：int a=33333, b=44444;
               a = a ^ b;
               b = a ^ b;
               a = a ^ b;
               a=?  b=?
            A：交换a、b的值，
               一个数位异或另外一个两次，等于这个数本身
        - 条件运算符（三目运算符、三元运算符）
           操作数1 ? 操作数2 : 操作数3
           根据“操作数1”的真假来选择 操作数2 或 操作数3 
                作为整个表达式的结果。
        - 赋值运算符
            - 简单赋值运算符 =
            - 复合赋值运算符 += -= *= ....
                num+=2       num = num+2
            - 结合性：从右到左
            Q：int a,b,c,d=3;
               a=b=c=d; a? b? c?
            A: =3
            - 优先级 倒数第二
        - 逗号运算符
            - 优先级 最低
            - 取右操作数作为整个表达式的结果
            Q：int a=3,b=4,c;    c=a,b;   c?
            A：3
            Q：int a=3,b=4,c;    c=(a,b);   c?
            A：4
            
        - sizeof运算符
            - sizeof是运算符！不是函数！
            - 求字节数
            Q：int arr[4];  
               int * p = arr;
               sizeof(arr);
               sizeof(p);
            A：16、4
            
    - 类型转换
        - 显示类型转换（强制类型转换）
            - 显示类型转换运算符 (操作数1)操作数2
              10/3   =>  3
              (double)10/3   => 3.3333...
              (double)(10/3) => 3.0000...
        
        - 隐式类型转换（类型提升）
            10*1.0/3  => 3.3333...
            10/3*1.0  => 3.0000...
        
            long double
             |
            double  <-  float
             |
            long long
             |
            long
             |
            int <-  char、short
        
第4章
    - 流程图
        1、能够画出流程图
        2、能够根据流程图写程序
            分清楚“判断框”对应的到底是 分支语句 还是 循环语句。
            分清楚“循环结构”到底是 for/while 还是 do...while。
            for/while 先判断 后执行循环体
            do...while 先执行循环体 后判断
    - break
        - 跳出当前循环 或 跳出当前switch语句
        - 跳出是离它最近的结构。
        
    - continue
        - 跳过当前循环，直接执行下次循环。
        
    - switch:
        - 执行某分支时，如果没有遇到break，则会一直往下执行。
        Q：for(i=0; i<10; i++) {
               switch(i) {
               case 1: i++;
               case 2: i++;
               case 5: i++;
               case 6: i++; break;
               default: i++; 
               }
               printf("%d\n", i);
           }
           
第5章
    - 一维数组
        - 初始化
            - 如果数组没有初始化，所有元素的值是不确定的
            - 如果只进行了部分初始化，未指定初始值的元素值为0
            - 如果通过初始化列表初始化，可以省略数组长度
                int arr[] = {1,2,3,4};  // 4
                char arr[] = "abcd";    // 5
        - 赋值
            - 只允许给指定元素赋值
            - 不允许数组直接整体赋值
                int arr1[4] = {1,2,3,4};
                int arr2[4];
                arr2 = arr1; （错误！）
                
                for(i=0;i<4;i++)
                    arr2[i]=arr1[i];
    - 二维数组
        - 理解
            1、作为矩阵理解
            2、存放一维数组的一维数组
        - 省略长度，只能省略行数！
            int arr[][3] = {1,2,3,4};
        
    - 字符串
        - C语言没有提供直接存储字符串的类型，想要存储字符串，
          只能使用字符数组来存储。
          char str[] = "abcd";
          
        - 字符串    一定是    字符数组
        - 字符数组  不一定是  字符串 
            当字符数组中有'\0'时，我们就认为这个字符数组是字符串。
            Q：char arr[4] = {0};  是不是字符串
            A：是
            Q：char arr[4] = {'a','b','c','d'};  是不是字符串
            A：不是
            
        - 字符串的赋值
            char a[] = "abcd";  char b[5];
            b = a; （错误！）
            strcpy(b, a);
        
        - 字符串相关函数
            - strcpy、strcmp、strcat、strlen
            - 必须能够自己实现！
第六章：
	指针：地址就是指针
	*：寻址符
	&：取地址符
	指针-指针：指针相减求两个指针之间单位元素的个数
		int arr[4]={1,2,3,4};
		int *p1=&arr[0];
		int *p2=&arr[3];
		p2-p1=3
        
        
    
    
    
    
    
    
        
        
        